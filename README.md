# 2048游戏 - 控制台版本

这是一个使用C语言编写的2048游戏控制台版本，支持键盘控制、颜色主题和自动测试功能。

## 项目概览

2048是一个数字拼图游戏，玩家通过滑动瓦片合并相同数字，目标是创建一个值为2048的瓦片。本项目提供了一个完整的C语言实现，包含游戏逻辑、用户界面和测试模块。

## 项目结构

```
2048/
├── CMakeLists.txt          # CMake构建配置文件
├── README.md               # 项目说明文档
├── LICENSE                 # 许可证文件
├── include/                # 头文件目录
│   ├── game.h             # 游戏逻辑相关声明
│   └── ui.h               # 用户界面相关声明
├── src/                   # 源代码目录
│   ├── main.c             # 主程序入口
│   ├── game.c             # 游戏逻辑实现
│   └── ui.c               # 用户界面实现
├── tests/                 # 测试代码目录
│   └── test_game.c        # 游戏测试用例
└── build/                 # 构建输出目录
    ├── 2048               # 主程序可执行文件
    ├── 2048_test          # 测试程序可执行文件
    └── ...                # 其他构建文件
```

## 编译和运行

### 系统要求

- C编译器（GCC或Clang）
- CMake 3.12或更高版本
- 支持ANSI转义序列的终端
- Unix-like系统（macOS、Linux等）

### 编译步骤

1. **克隆或下载项目**
   ```bash
   cd /path/to/2048
   ```

2. **创建构建目录**
   ```bash
   mkdir -p build
   cd build
   ```

3. **配置CMake**
   ```bash
   cmake ..
   ```

4. **编译项目**
   ```bash
   make
   ```

### 运行游戏

1. **运行标准游戏**
   ```bash
   ./2048
   ```

2. **使用不同颜色主题**
   ```bash
   ./2048 blackwhite    # 黑白主题
   ./2048 bluered       # 蓝红主题
   ```

3. **查看帮助信息**
   ```bash
   ./2048 --help
   ```

4. **查看版本信息**
   ```bash
   ./2048 --version
   ```

5. **运行测试**
   ```bash
   ./2048 test
   ```

### 游戏控制

- **方向键**：← ↑ → ↓ 或 WASD 或 HJKL 或 数字键盘
- **退出游戏**：按 `q` 然后确认
- **重新开始**：按 `r` 然后确认

## 详细代码分析

### 常量定义

#### game.h 中的常量

```c
#define SIZE 4              // 游戏板大小（4x4网格）
#define VERSION "1.0.3"     // 程序版本号
```

**常量说明：**
- `SIZE`：定义游戏板的尺寸，标准2048游戏使用4x4的网格
- `VERSION`：程序版本字符串，用于版本信息显示

### 数据结构

#### Game结构体

```c
typedef struct
{
    uint8_t board[SIZE][SIZE];  // 游戏板，存储每个位置的数值
    uint32_t score;             // 当前游戏得分
} Game;
```

**说明：**
- `board`：二维数组表示游戏板，每个元素存储该位置的数值（以2的幂次表示）
- `score`：累计得分，合并瓦片时增加

### 核心函数详解

#### 1. 游戏初始化函数

```c
void initBoard(uint8_t board[SIZE][SIZE])
```

**功能：** 初始化游戏板，清空所有位置并随机添加两个初始瓦片。

**实现逻辑：**
1. 将整个游戏板清零
2. 调用两次`addRandom()`函数添加初始瓦片

**关键代码分析：**
```c
for (x = 0; x < SIZE; x++)
{
    for (y = 0; y < SIZE; y++)
    {
        board[x][y] = 0;  // 清空所有位置
    }
}
addRandom(board);  // 添加第一个随机瓦片
addRandom(board);  // 添加第二个随机瓦片
```

#### 2. 随机瓦片添加函数

```c
void addRandom(uint8_t board[SIZE][SIZE])
```

**功能：** 在游戏板的空位置随机添加一个新瓦片。

**实现逻辑：**
1. 初始化随机数生成器（仅第一次调用）
2. 遍历游戏板找出所有空位置
3. 从空位置中随机选择一个
4. 在选中位置放置数值1（表示2）或2（表示4），90%概率为2，10%概率为4

**关键代码分析：**
```c
// 收集所有空位置
for (x = 0; x < SIZE; x++)
{
    for (y = 0; y < SIZE; y++)
    {
        if (board[x][y] == 0)
        {
            list[len][0] = x;  // 记录x坐标
            list[len][1] = y;  // 记录y坐标
            len++;
        }
    }
}

// 随机选择位置并放置瓦片
if (len > 0)
{
    r = rand() % len;      // 随机选择空位置
    x = list[r][0];
    y = list[r][1];
    n = (rand() % 10) / 9 + 1;  // 90%概率为1(=2)，10%概率为2(=4)
    board[x][y] = n;
}
```

#### 3. 数组滑动函数

```c
bool slideArray(uint8_t array[SIZE], uint32_t *score)
```

**功能：** 核心算法函数，实现一行（或一列）的滑动和合并逻辑。

**实现逻辑：**
1. 从左到右遍历数组中的每个非零元素
2. 使用`findTarget()`找到当前元素应该移动到的目标位置
3. 如果目标位置为空，直接移动
4. 如果目标位置有相同数值，进行合并并更新得分
5. 清空原位置

**关键代码分析：**
```c
for (x = 0; x < SIZE; x++)
{
    if (array[x] != 0)  // 只处理非零元素
    {
        t = findTarget(array, x, stop);  // 找到目标位置
        if (t != x)  // 需要移动
        {
            if (array[t] == 0)  // 目标位置为空
            {
                array[t] = array[x];  // 直接移动
            }
            else if (array[t] == array[x])  // 目标位置有相同数值
            {
                array[t]++;  // 合并（数值加1，因为存储的是2的幂次）
                *score += 1 << array[t];  // 更新得分
                stop = t + 1;  // 设置停止位置，防止连续合并
            }
            array[x] = 0;  // 清空原位置
            success = true;
        }
    }
}
```

#### 4. 目标位置查找函数

```c
uint8_t findTarget(uint8_t array[SIZE], uint8_t x, uint8_t stop)
```

**功能：** 为给定位置的元素找到最终应该移动到的目标位置。

**参数说明：**
- `array`：待处理的数组
- `x`：当前元素的位置
- `stop`：停止搜索的位置（用于防止重复合并）

**实现逻辑：**
1. 从当前位置向左搜索
2. 遇到非零元素时检查是否可以合并
3. 如果可以合并，返回该位置；否则返回下一个位置
4. 如果一直到停止位置都是空的，返回停止位置

#### 5. 游戏板旋转函数

```c
void rotateBoard(uint8_t board[SIZE][SIZE])
```

**功能：** 将游戏板顺时针旋转90度，用于实现不同方向的移动。

**实现逻辑：**
使用经典的矩阵旋转算法，通过环形交换实现原地旋转。

**关键代码分析：**
```c
for (i = 0; i < n / 2; i++)  // 处理每一圈
{
    for (j = i; j < n - i - 1; j++)  // 处理当前圈的每个位置
    {
        // 四个位置的环形交换
        tmp = board[i][j];
        board[i][j] = board[j][n - i - 1];
        board[j][n - i - 1] = board[n - i - 1][n - j - 1];
        board[n - i - 1][n - j - 1] = board[n - j - 1][i];
        board[n - j - 1][i] = tmp;
    }
}
```

#### 6. 方向移动函数

```c
bool moveUp(uint8_t board[SIZE][SIZE], uint32_t *score)
bool moveLeft(uint8_t board[SIZE][SIZE], uint32_t *score)
bool moveDown(uint8_t board[SIZE][SIZE], uint32_t *score)
bool moveRight(uint8_t board[SIZE][SIZE], uint32_t *score)
```

**功能：** 实现四个方向的移动操作。

**实现原理：**
- `moveUp`：直接对每列调用`slideArray`
- `moveLeft`：旋转1次 → moveUp → 旋转3次还原
- `moveDown`：旋转2次 → moveUp → 旋转2次还原  
- `moveRight`：旋转3次 → moveUp → 旋转1次还原

这种设计避免了重复编写相似的逻辑，只需要实现一个方向的移动，其他方向通过旋转实现。

#### 7. 游戏结束判断函数

```c
bool gameEnded(uint8_t board[SIZE][SIZE])
```

**功能：** 判断游戏是否结束（无法继续移动）。

**判断逻辑：**
1. 如果还有空位置，游戏继续
2. 检查垂直方向是否有相邻的相同数字
3. 旋转游戏板检查水平方向是否有相邻的相同数字
4. 如果都没有，游戏结束

#### 8. 空位置计数函数

```c
uint8_t countEmpty(uint8_t board[SIZE][SIZE])
```

**功能：** 统计游戏板上空位置的数量。

**实现：** 遍历整个游戏板，计算值为0的位置数量。

#### 9. 相邻对查找函数

```c
bool findPairDown(uint8_t board[SIZE][SIZE])
```

**功能：** 检查垂直方向是否存在相邻的相同数字。

**实现：** 遍历每列，检查相邻行是否有相同数值。

### 用户界面函数

#### 1. 颜色获取函数

```c
void getColors(uint8_t value, uint8_t scheme, uint8_t *foreground, uint8_t *background)
```

**功能：** 根据数值和颜色方案获取前景色和背景色。

**支持的颜色方案：**
- `0`：原始配色方案
- `1`：黑白配色方案（blackwhite）
- `2`：蓝红配色方案（bluered）

#### 2. 数字位数计算函数

```c
uint8_t getDigitCount(uint32_t number)
```

**功能：** 计算数字的位数，用于界面对齐。

#### 3. 游戏板绘制函数

```c
void drawBoard(uint8_t board[SIZE][SIZE], uint8_t scheme, uint32_t score)
```

**功能：** 在终端中绘制游戏板和分数。

**实现特点：**
- 使用ANSI转义序列控制光标位置和颜色
- 每个瓦片用7x3字符的矩形表示
- 空位置显示为圆点"·"
- 显示当前分数和操作提示

#### 4. 缓冲输入控制函数

```c
void setBufferedInput(bool enable)
```

**功能：** 控制终端输入模式，实现实时按键响应。

**实现原理：**
- 关闭行缓冲（`ICANON`）使按键立即响应
- 关闭回显（`ECHO`）避免按键字符显示在屏幕上

### 测试函数

#### 测试成功函数

```c
bool testSucceed(void)
```

**功能：** 运行预定义的测试用例验证游戏逻辑正确性。

**测试内容：**
包含13个测试用例，验证`slideArray`函数在各种情况下的行为：
- 空数组处理
- 单个元素移动
- 两个相同元素合并
- 复杂的合并和移动组合

### 主程序逻辑

#### 主函数

```c
int main(int argc, char *argv[])
```

**功能：** 程序入口，处理命令行参数并运行游戏主循环。

**支持的命令行选项：**
- `-h, --help`：显示帮助信息
- `-v, --version`：显示版本信息
- `blackwhite`：使用黑白配色
- `bluered`：使用蓝红配色
- `test`：运行测试模式

**游戏主循环：**
1. 初始化游戏板和终端设置
2. 等待用户输入
3. 根据按键执行相应的移动操作
4. 更新显示并检查游戏状态
5. 处理特殊命令（退出、重启）

**按键映射：**
- 左移：`4`, `a`, `h`, `←`
- 右移：`6`, `d`, `l`, `→`
- 上移：`8`, `w`, `k`, `↑`
- 下移：`2`, `s`, `j`, `↓`
- 退出：`q`
- 重启：`r`

## 数值存储机制

游戏使用一种巧妙的存储方式：
- 存储值0表示空位置
- 存储值1表示数字2（2^1）
- 存储值2表示数字4（2^2）
- 存储值3表示数字8（2^3）
- 以此类推...

这种方式的优点：
1. 节省存储空间（使用uint8_t而非uint32_t）
2. 合并操作简化为加法（value1 == value2时，结果为value1 + 1）
3. 显示时通过`1 << value`计算实际数值

## 项目特点

1. **模块化设计**：游戏逻辑、用户界面和主程序分离
2. **跨平台兼容**：使用标准C库和POSIX接口
3. **内存高效**：使用8位整数存储游戏状态
4. **丰富的视觉效果**：支持多种颜色主题
5. **完整的测试**：包含自动化测试验证游戏逻辑
6. **灵活的构建系统**：使用CMake支持多种编译器

## 开发和扩展

### 添加新功能

1. **新的颜色主题**：在`ui.c`的颜色数组中添加新方案
2. **不同游戏板尺寸**：修改`SIZE`常量（需要相应调整界面）
3. **保存/加载功能**：添加文件I/O操作保存游戏状态
4. **最高分记录**：添加持久化存储记录历史最高分

### 性能优化

当前实现已经针对4x4游戏板进行了优化：
- 使用位运算进行数值计算
- 最小化内存分配
- 高效的矩阵旋转算法

## 许可证

本项目使用开源许可证，具体信息请查看LICENSE文件。

## 贡献

欢迎提交问题报告、功能请求或代码贡献。请确保：
1. 遵循现有的代码风格
2. 添加适当的测试用例
3. 更新相关文档

---

**作者**：Maurits van der Schee  
**版本**：1.0.3  
**最后更新**：2025年8月28日